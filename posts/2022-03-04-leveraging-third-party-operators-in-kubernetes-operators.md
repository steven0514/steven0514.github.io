---
id: 4749
title: 'Leveraging third party Operators in Kubernetes Operators'
date: '2022-03-04T15:18:16+00:00'
author: 'Niklas Heidloff'
layout: post
guid: 'http://heidloff.net/?p=4749'
permalink: /article/leveraging-third-party-operators-in-kubernetes-operators/
accesspresslite_sidebar_layout:
    - right-sidebar
custom_permalink:
    - article/leveraging-third-party-operators-in-kubernetes-operators/
categories:
    - Articles
---

*This article summarizes how to use third party operators in your own operators in order to provide an easier user experience.*

Let me first explain why multiple layers of operators make sense using a concrete scenario. My little [sample operator](https://github.com/nheidloff/quarkus-operator-microservice-database) shows how to deploy a microservice which uses a managed database in the IBM Cloud. The microservice is deployed via my custom operator. The managed database is deployed via the [IBM Cloud Operator](https://github.com/IBM/cloud-operators).

From a user experience standpoint I’d like to have one [single yaml](https://github.com/nheidloff/quarkus-operator-microservice-database/blob/7fcd1599bb24710369569065f1ee73b489b8f251/kubernetes/ecommercesample.yaml) which is as short as possible.

```
apiVersion: "ecommercesample.com/v1alpha1"
kind: ECommerceSample
metadata:
  name: ecommercesample1
  namespace: tenant1
spec:
  sqlUrl: https://raw.githubusercontent.com/IBM/multi-tenancy/main/installapp/postgres-config/create-populate-tenant-a.sql
  appTitle: Movies
```

The following yaml shows to how deploy a Postgres database on the IBM Cloud. Service creates the instance, Binding stores the Postgres credentials in a Kubernetes secret after the service has be created and initialized. This [yaml](https://github.com/nheidloff/quarkus-operator-microservice-database/blob/7fcd1599bb24710369569065f1ee73b489b8f251/kubernetes/postgres.yaml) should not be visible to users. Instead it should be generated by the custom operator.

```
apiVersion: ibmcloud.ibm.com/v1
kind: Service
metadata:
  name: ecommercesample1
  namespace: tenant1
spec:
  plan: standard
  serviceClass: databases-for-postgresql
---
apiVersion: ibmcloud.ibm.com/v1
kind: Binding
metadata:
  name: binding-ecommercesample1
  namespace: tenant1
spec:
  serviceName: ecommercesample1
  secretName: ecommercesample1-secret
```

The implementation is actually pretty straight forward. Let’s take a look how to trigger the creation of the Postgres resources in the [reconcile](https://github.com/nheidloff/quarkus-operator-microservice-database/blob/7fcd1599bb24710369569065f1ee73b489b8f251/src/main/java/com/ecommercesample/ECommerceSampleController.java#L73-L90) loop using Quarkus and the [Java Operator SDK](https://javaoperatorsdk.io/).

The trick is to generate the Postgres Service and Binding definition with Java in JSON format and then to use the GenericKubernetesResource API.

![image](/assets/img/2022/03/Screenshot-2022-03-03-at-16.07.36.png)

Since the creation can take a good amount of time and since you should use this pattern anyway in the reconcile loop, the deployment code of the microservice only continues in a future loop run once the secret with Postgres credentials is available in Kubernetes.

```
secret = client.secrets().inNamespace(namespace).withName(ibmOperatorBindingSecretName).get();        
if (secret == null) {
    System.out.println("Secret " + ibmOperatorBindingSecretName + " does not exist");
    return UpdateControl.updateCustomResource(resource);
}
```

Keep an eye on this blog to find out more about how to build operators.